/* -*- C -*- */
%%
headers
#define NO_IMPORT_PYGOBJECT
#include "pygobject.h"

#include <gtksourceview/gtksourceview.h>
#include <gtksourceview/gtksourceview-typebuiltins.h>
#include <gtksourceview/gtksourcelanguagemanager.h>
#include <gtksourceview/gtksourcestylemanager.h>
#include <gtksourceview/gtksourcestyle.h>
#include <gtksourceview/gtksourcestylescheme.h>
#include <gtksourceview/gtksourcemarker.h>
#include <gtksourceview/gtksourcelanguage.h>
#include <gtksourceview/gtksourceiter.h>
#include <gtksourceview/gtksourcebuffer.h>

static PyObject *
gslist_to_pylist_objs (const GSList *source)
{
    const GSList *iter;
    PyObject *dest = PyList_New (0);
    for (iter = source; iter != NULL; iter = iter->next)
    {
        PyObject *item = pygobject_new ((GObject *)iter->data);
        PyList_Append (dest, item);
        Py_DECREF (item);
    }
    return dest;
}

static PyObject *
strv_to_pylist (char **strv)
{
    gsize len, i;
    PyObject *list;

    len = strv ? g_strv_length (strv) : 0;
    list = PyList_New (len);

    for (i = 0; i < len; i++)
        PyList_SetItem (list, i, PyString_FromString (strv[i]));

    return list;
}

static gboolean
pylist_to_strv (PyObject *list,
                char   ***strvp)
{
    int i, len;
    char **ret;

    *strvp = NULL;

    if (list == Py_None)
        return TRUE;

    if (!PySequence_Check (list))
    {
        PyErr_Format (PyExc_TypeError, "argument must be a list or tuple of strings");
        return FALSE;
    }

    if ((len = PySequence_Size (list)) < 0)
        return FALSE;

    ret = g_new (char*, len + 1);
    for (i = 0; i <= len; ++i)
        ret[i] = NULL;

    for (i = 0; i < len; ++i)
    {
        PyObject *item = PySequence_GetItem (list, i);

        if (!item)
        {
            g_strfreev (ret);
            return FALSE;
        }

        if (!PyString_Check (item))
        {
            Py_DECREF (item);
            g_strfreev (ret);
            PyErr_Format (PyExc_TypeError, "argument must be a list of strings");
            return FALSE;
        }

        ret[i] = g_strdup (PyString_AsString (item));
        Py_DECREF (item);
    }

    *strvp = ret;
    return TRUE;
}

%%
modulename gtksourceview2

%%
import gobject.GObject as PyGObject_Type
import gtk.gdk.Pixbuf as PyGdkPixbuf_Type
import gtk.TextTagTable as PyGtkTextTagTable_Type
import gtk.TextView as PyGtkTextView_Type
import gtk.TextBuffer as PyGtkTextBuffer_Type
import gtk.TextMark as PyGtkTextMark_Type

%%
ignore-glob
*_get_type
%%
override gtk_source_language_get_globs noargs
static PyObject *
_wrap_gtk_source_language_get_globs(PyGObject *self)
{
    gchar **globs;
    PyObject *ret;

    globs = gtk_source_language_get_globs (GTK_SOURCE_LANGUAGE (self->obj));
    ret = strv_to_pylist (globs);
    g_strfreev (globs);

    return ret;
}

%%
override gtk_source_buffer_get_markers_in_region kwargs
static PyObject *
_wrap_gtk_source_buffer_get_markers_in_region(PyGObject *self,
                                              PyObject *args,
                                              PyObject *kwargs)
{
    static char *kwlist[] = { "begin", "end", NULL };
    PyObject    *py_begin, *py_end, *py_ret;
    GtkTextIter *begin = NULL, *end = NULL;
    GSList      *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "OO:GtkSourceBuffer.get_markers_in_region",
                                     kwlist, &py_begin, &py_end))
        return NULL;

    if (pyg_boxed_check(py_begin, GTK_TYPE_TEXT_ITER))
        begin = pyg_boxed_get(py_begin, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "begin should be a GtkTextIter");
        return NULL;
    }
    
    if (pyg_boxed_check(py_end, GTK_TYPE_TEXT_ITER))
        end = pyg_boxed_get(py_end, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "end should be a GtkTextIter");
        return NULL;
    }
    
    ret = gtk_source_buffer_get_markers_in_region(GTK_SOURCE_BUFFER(self->obj),
                                                  begin, end);
    
    py_ret = gslist_to_pylist_objs (ret);
    
    return py_ret;    
}

%%
override gtk_source_language_get_mime_types noargs
static PyObject *
_wrap_gtk_source_language_get_mime_types(PyGObject *self)
{
    gchar **mime_types;
    PyObject *ret;

    mime_types = gtk_source_language_get_mime_types (GTK_SOURCE_LANGUAGE (self->obj));
    ret = strv_to_pylist (mime_types);
    g_strfreev (mime_types);

    return ret;
}

%%
override gtk_source_language_manager_get_available_languages noargs
static PyObject *
_wrap_gtk_source_language_manager_get_available_languages(PyGObject *self)
{
    PyObject        *py_ret;
    const GSList    *ret;
    
    ret = gtk_source_language_manager_get_available_languages(GTK_SOURCE_LANGUAGE_MANAGER(self->obj));
    
    py_ret = gslist_to_pylist_objs(ret);
    
    return py_ret;
}

%%
override gtk_source_language_manager_get_search_path noargs
static PyObject *
_wrap_gtk_source_language_manager_get_search_path(PyGObject *self)
{
    gchar **ret;
    PyObject  *py_ret;

    ret = gtk_source_language_manager_get_search_path(GTK_SOURCE_LANGUAGE_MANAGER(self->obj));
    py_ret = strv_to_pylist (ret);

    return py_ret;
}

%%
override gtk_source_language_manager_set_search_path kwargs
static PyObject *
_wrap_gtk_source_language_manager_set_search_path (PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "dirs", NULL };
    PyObject *py_dirs;
    char **dirs;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:GtkSourceLanguageManager.set_search_path", kwlist, &py_dirs))
        return NULL;

    if (!pylist_to_strv (py_dirs, &dirs))
        return NULL;

    gtk_source_language_manager_set_search_path (GTK_SOURCE_LANGUAGE_MANAGER (self->obj), dirs);
    g_strfreev (dirs);

    Py_INCREF(Py_None);
    return Py_None;
}

%%
override gtk_source_style_manager_get_search_path noargs
static PyObject *
_wrap_gtk_source_style_manager_get_search_path(PyGObject *self)
{
    gchar **ret;
    PyObject *py_ret;

    ret = gtk_source_style_manager_get_search_path (GTK_SOURCE_STYLE_MANAGER (self->obj));
    py_ret = strv_to_pylist (ret);

    return py_ret;
}

%%
override gtk_source_style_manager_set_search_path kwargs
static PyObject *
_wrap_gtk_source_style_manager_set_search_path(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "dirs", NULL };
    PyObject *py_dirs;
    char **dirs;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:GtkSourceStyleManager.set_search_path", kwlist, &py_dirs))
        return NULL;

    if (!pylist_to_strv (py_dirs, &dirs))
        return NULL;

    gtk_source_style_manager_set_search_path (GTK_SOURCE_STYLE_MANAGER (self->obj), dirs);
    g_strfreev (dirs);

    Py_INCREF(Py_None);
    return Py_None;
}

%%
override gtk_source_style_manager_list_schemes noargs
static PyObject *
_wrap_gtk_source_style_manager_list_schemes(PyGObject *self)
{
    PyObject *py_ret;
    GSList *ret;

    ret = gtk_source_style_manager_list_schemes(GTK_SOURCE_STYLE_MANAGER(self->obj));
    py_ret = gslist_to_pylist_objs(ret);

    return py_ret;
}
