/* -*- C -*- */
%%
headers
#define NO_IMPORT_PYGOBJECT
#include "pygobject.h"

#include <gtksourceview/gtksourceview.h>
#include <gtksourceview/gtksourceview-typebuiltins.h>
#include <gtksourceview/gtksourcelanguagemanager.h>
#include <gtksourceview/gtksourcestyleschememanager.h>
#include <gtksourceview/gtksourcestyle.h>
#include <gtksourceview/gtksourcestylescheme.h>
#include <gtksourceview/gtksourcelanguage.h>
#include <gtksourceview/gtksourceiter.h>
#include <gtksourceview/gtksourcebuffer.h>
#include <gtksourceview/gtksourceprintcompositor.h>
#include <gtksourceview/gtksourcecompletion.h>
#include <gtksourceview/gtksourcecompletionitem.h>
#include <gtksourceview/gtksourcecompletionprovider.h>
#include <gtksourceview/gtksourcecompletioninfo.h>

static PyObject *
gslist_to_pylist_objs (const GSList *source)
{
    const GSList *iter;
    PyObject *dest = PyList_New (0);
    for (iter = source; iter != NULL; iter = iter->next)
    {
        PyObject *item = pygobject_new ((GObject *)iter->data);
        PyList_Append (dest, item);
        Py_DECREF (item);
    }
    return dest;
}

static PyObject *
glist_to_pylist_objs (const GList *source)
{
    const GList *iter;
    PyObject *dest = PyList_New (0);
    for (iter = source; iter != NULL; iter = iter->next)
    {
        PyObject *item = pygobject_new ((GObject *)iter->data);
        PyList_Append (dest, item);
        Py_DECREF (item);
    }
    return dest;
}

static PyObject *
strv_to_pylist (char **strv)
{
    gsize len, i;
    PyObject *list;

    len = strv ? g_strv_length (strv) : 0;
    list = PyList_New (len);

    for (i = 0; i < len; i++)
        PyList_SetItem (list, i, PyString_FromString (strv[i]));

    return list;
}

static gboolean
pylist_to_strv (PyObject *list,
                char   ***strvp)
{
    int i, len;
    char **ret;

    *strvp = NULL;

    if (list == Py_None)
        return TRUE;

    if (!PySequence_Check (list))
    {
        PyErr_Format (PyExc_TypeError, "argument must be a list or tuple of strings");
        return FALSE;
    }

    if ((len = PySequence_Size (list)) < 0)
        return FALSE;

    ret = g_new (char*, len + 1);
    for (i = 0; i <= len; ++i)
        ret[i] = NULL;

    for (i = 0; i < len; ++i)
    {
        PyObject *item = PySequence_GetItem (list, i);

        if (!item)
        {
            g_strfreev (ret);
            return FALSE;
        }

        if (!PyString_Check (item))
        {
            Py_DECREF (item);
            g_strfreev (ret);
            PyErr_Format (PyExc_TypeError, "argument must be a list of strings");
            return FALSE;
        }

        ret[i] = g_strdup (PyString_AsString (item));
        Py_DECREF (item);
    }

    *strvp = ret;
    return TRUE;
}

%%
modulename gtksourceview2

%%
import gobject.GObject as PyGObject_Type
import gtk.gdk.Pixbuf as PyGdkPixbuf_Type
import gtk.TextTagTable as PyGtkTextTagTable_Type
import gtk.TextView as PyGtkTextView_Type
import gtk.TextBuffer as PyGtkTextBuffer_Type
import gtk.TextMark as PyGtkTextMark_Type
import gtk.PrintContext as PyGtkPrintContext_Type
import gtk.Widget as PyGtkWidget_Type
import gtk.Window as PyGtkWindow_Type
import gtk.TextIter as PyGtkTextIter_Type
%%
ignore-glob
*_get_type
gtk_source_completion_item_new_from_stock
%%
override gtk_source_language_get_globs noargs
static PyObject *
_wrap_gtk_source_language_get_globs(PyGObject *self)
{
    gchar **globs;
    PyObject *ret;

    globs = gtk_source_language_get_globs (GTK_SOURCE_LANGUAGE (self->obj));
    ret = strv_to_pylist (globs);
    g_strfreev (globs);

    return ret;
}

%%
override gtk_source_language_get_mime_types noargs
static PyObject *
_wrap_gtk_source_language_get_mime_types(PyGObject *self)
{
    gchar **mime_types;
    PyObject *ret;

    mime_types = gtk_source_language_get_mime_types (GTK_SOURCE_LANGUAGE (self->obj));
    ret = strv_to_pylist (mime_types);
    g_strfreev (mime_types);

    return ret;
}

%%
override gtk_source_language_manager_get_language_ids noargs
static PyObject *
_wrap_gtk_source_language_manager_get_language_ids (PyGObject *self)
{
    PyObject *py_ret;
    const char * const *ret;

    ret = gtk_source_language_manager_get_language_ids (GTK_SOURCE_LANGUAGE_MANAGER (self->obj));
    py_ret = strv_to_pylist ((char**) ret);

    return py_ret;
}

%%
override gtk_source_language_manager_get_search_path noargs
static PyObject *
_wrap_gtk_source_language_manager_get_search_path(PyGObject *self)
{
    const char * const *ret;
    PyObject  *py_ret;

    ret = gtk_source_language_manager_get_search_path (GTK_SOURCE_LANGUAGE_MANAGER(self->obj));
    py_ret = strv_to_pylist ((char**) ret);

    return py_ret;
}

%%
override gtk_source_language_manager_set_search_path kwargs
static PyObject *
_wrap_gtk_source_language_manager_set_search_path (PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "dirs", NULL };
    PyObject *py_dirs;
    char **dirs;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:GtkSourceLanguageManager.set_search_path", kwlist, &py_dirs))
        return NULL;

    if (!pylist_to_strv (py_dirs, &dirs))
        return NULL;

    gtk_source_language_manager_set_search_path (GTK_SOURCE_LANGUAGE_MANAGER (self->obj), dirs);
    g_strfreev (dirs);

    Py_INCREF(Py_None);
    return Py_None;
}

%%
override gtk_source_style_scheme_manager_get_search_path noargs
static PyObject *
_wrap_gtk_source_style_scheme_manager_get_search_path(PyGObject *self)
{
    const char * const *ret;
    PyObject *py_ret;

    ret = gtk_source_style_scheme_manager_get_search_path (GTK_SOURCE_STYLE_SCHEME_MANAGER (self->obj));
    py_ret = strv_to_pylist ((char**) ret);

    return py_ret;
}

%%
override gtk_source_style_scheme_manager_set_search_path kwargs
static PyObject *
_wrap_gtk_source_style_scheme_manager_set_search_path(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "dirs", NULL };
    PyObject *py_dirs;
    char **dirs;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:GtkSourceStyleSchemeManager.set_search_path", kwlist, &py_dirs))
        return NULL;

    if (!pylist_to_strv (py_dirs, &dirs))
        return NULL;

    gtk_source_style_scheme_manager_set_search_path (GTK_SOURCE_STYLE_SCHEME_MANAGER (self->obj), dirs);
    g_strfreev (dirs);

    Py_INCREF(Py_None);
    return Py_None;
}

%%
override gtk_source_style_scheme_manager_get_scheme_ids noargs
static PyObject *
_wrap_gtk_source_style_scheme_manager_get_scheme_ids (PyGObject *self)
{
    PyObject *py_ret;
    const char * const *ret;

    ret = gtk_source_style_scheme_manager_get_scheme_ids (GTK_SOURCE_STYLE_SCHEME_MANAGER (self->obj));
    py_ret = strv_to_pylist ((char**) ret);

    return py_ret;
}

%%
override gtk_source_style_scheme_get_authors noargs
static PyObject *
_wrap_gtk_source_style_scheme_get_authors (PyGObject *self)
{
    PyObject *py_ret;
    const char * const *ret;

    ret = gtk_source_style_scheme_get_authors (GTK_SOURCE_STYLE_SCHEME (self->obj));
    py_ret = strv_to_pylist ((char**) ret);

    return py_ret;
}

%%
override-slot GtkSourceLanguage.tp_new
static PyObject *
_wrap_gtk_source_language_tp_new(PyTypeObject *type)
{
    PyErr_SetString(PyExc_TypeError,
            "cannot create instance of type `GtkSourceLanguage'");
    return NULL;
}

%%
override-slot GtkSourceStyleScheme.tp_new
static PyObject *
_wrap_gtk_source_style_scheme_tp_new(PyTypeObject *type)
{
    PyErr_SetString(PyExc_TypeError,
            "cannot create instance of type `GtkSourceStyleScheme'");
    return NULL;
}

%%
override gtk_source_language_get_style_ids noargs
static PyObject *
_wrap_gtk_source_language_get_style_ids(PyGObject *self)
{
    gchar       **ret;
    PyObject    *py_ret;

    ret = gtk_source_language_get_style_ids(GTK_SOURCE_LANGUAGE(self->obj));
    py_ret = strv_to_pylist ((char**) ret);

    return py_ret;
}

%%
override gtk_source_buffer_get_source_marks_at_iter kwargs
static PyObject *
_wrap_gtk_source_buffer_get_source_marks_at_iter(PyGObject *self,
                                                 PyObject *args,
                                                 PyObject *kwargs)
{
    static char *kwlist[] = { "iter", "category", NULL };
    PyObject    *py_iter, *py_ret;
    gchar       *category;
    GtkTextIter *iter = NULL;
    GSList      *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "Oz:GtkSourceBuffer.get_source_marks_at_iter",
                                     kwlist, &py_iter, &category))
        return NULL;

    if (pyg_boxed_check(py_iter, GTK_TYPE_TEXT_ITER))
        iter = pyg_boxed_get(py_iter, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "iter should be a GtkTextIter");
        return NULL;
    }

    ret = gtk_source_buffer_get_source_marks_at_iter(GTK_SOURCE_BUFFER(self->obj),
                                                     iter, category);

    py_ret = gslist_to_pylist_objs (ret);

    return py_ret;
}

%%
override gtk_source_buffer_get_source_marks_at_line kwargs
static PyObject *
_wrap_gtk_source_buffer_get_source_marks_at_line(PyGObject *self,
                                                 PyObject *args,
                                                 PyObject *kwargs)
{
    static char *kwlist[] = { "line", "category", NULL };
    PyObject    *py_ret;
    gint        line;
    gchar       *category;
    GSList      *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "iz:GtkSourceBuffer.get_source_marks_at_line",
                                     kwlist, &line, &category))
        return NULL;

    ret = gtk_source_buffer_get_source_marks_at_line(GTK_SOURCE_BUFFER(self->obj),
                                                     line, category);

    py_ret = gslist_to_pylist_objs (ret);

    return py_ret;
}

%%
override gtk_source_iter_backward_search kwargs
static PyObject *
_wrap_gtk_source_iter_backward_search(PyObject *self, PyObject *args,
                                      PyObject *kwargs)
{
    static char *kwlist[] = { "iter", "str", "flags", "limit", NULL };
    gchar *str;
    PyObject *py_flags, *py_iter, *py_limit = Py_None;
    GtkTextIter match_start, match_end, *iter = NULL, *limit = NULL;
    GtkSourceSearchFlags flags;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                    "OsO|O:gtksourceview2.iter_backward_search",
                                    kwlist, &py_iter, &str, &py_flags,
                                    &py_limit))
        return NULL;

    if (pyg_boxed_check(py_iter, GTK_TYPE_TEXT_ITER))
        iter = pyg_boxed_get(py_iter, GtkTextIter);

    if (pyg_boxed_check(py_limit, GTK_TYPE_TEXT_ITER))
        limit = pyg_boxed_get(py_limit, GtkTextIter);

    else if (py_limit != Py_None) {
        PyErr_SetString(PyExc_TypeError,"limit must be a GtkTextIter or None");
        return NULL;
    }

    if (pyg_flags_get_value(GTK_TYPE_TEXT_SEARCH_FLAGS, py_flags,
                            (gint *)&flags))
        return NULL;

    if (gtk_source_iter_backward_search(iter, str, flags, &match_start,
                                        &match_end, limit))
        return Py_BuildValue("(NN)",
                             pyg_boxed_new(GTK_TYPE_TEXT_ITER, &match_start,
                                           TRUE, TRUE),
                             pyg_boxed_new(GTK_TYPE_TEXT_ITER, &match_end,
                                           TRUE, TRUE));

    Py_INCREF(Py_None);
    return Py_None;
}

%%
override gtk_source_iter_forward_search kwargs
static PyObject *
_wrap_gtk_source_iter_forward_search(PyObject *self, PyObject *args,
                                      PyObject *kwargs)
{
    static char *kwlist[] = { "iter", "str", "flags", "limit", NULL };
    gchar *str;
    PyObject *py_flags, *py_iter, *py_limit = Py_None;
    GtkTextIter match_start, match_end, *iter = NULL, *limit = NULL;
    GtkSourceSearchFlags flags;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                    "OsO|O:gtksourceview2.iter_forward_search",
                                    kwlist, &py_iter, &str, &py_flags,
                                    &py_limit))
        return NULL;

    if (pyg_boxed_check(py_iter, GTK_TYPE_TEXT_ITER))
        iter = pyg_boxed_get(py_iter, GtkTextIter);

    if (pyg_boxed_check(py_limit, GTK_TYPE_TEXT_ITER))
        limit = pyg_boxed_get(py_limit, GtkTextIter);

    else if (py_limit != Py_None) {
        PyErr_SetString(PyExc_TypeError,"limit must be a GtkTextIter or None");
        return NULL;
    }

    if (pyg_flags_get_value(GTK_TYPE_TEXT_SEARCH_FLAGS, py_flags,
                            (gint *)&flags))
        return NULL;

    if (gtk_source_iter_forward_search(iter, str, flags, &match_start,
                                        &match_end, limit))
        return Py_BuildValue("(NN)",
                             pyg_boxed_new(GTK_TYPE_TEXT_ITER, &match_start,
                                           TRUE, TRUE),
                             pyg_boxed_new(GTK_TYPE_TEXT_ITER, &match_end,
                                           TRUE, TRUE));

    Py_INCREF(Py_None);
    return Py_None;
}

%%
override gtk_source_view_get_mark_category_background kwargs
static PyObject *
_wrap_gtk_source_view_get_mark_category_background(PyGObject *self,
                                                   PyObject *args,
                                                   PyObject *kwargs)
{
    static char *kwlist[] = { "category", NULL };
    char *category;
    int ret;
    GdkColor dest = { 0, 0, 0, 0 };

    if (!PyArg_ParseTupleAndKeywords(args,
                                kwargs,
                                "s:GtkSourceView.get_mark_category_background",
                                kwlist, &category))
        return NULL;

    ret = gtk_source_view_get_mark_category_background(
                                                    GTK_SOURCE_VIEW(self->obj),
                                                    category, &dest);

    if (ret)
        return pyg_boxed_new(GDK_TYPE_COLOR, &dest, TRUE, TRUE);
    else {
        Py_INCREF(Py_None);
        return(Py_None);
    }
}

%%
override gtk_source_view_show_completion kwargs

static GList *
pylist_to_glist_gobjs (PyObject *object, GType gtype)
{
    PyObject *item;
    GObject *obj;
    GList *ret = NULL;
    int num;
    int i;
    
    if (object == Py_None) {
        return ret;
    }
    
    num = PySequence_Size (object);
    
    for (i = 0; i < num; ++i) {
        item = PySequence_GetItem (object, i);
        
        if (PyObject_TypeCheck(item, &PyGObject_Type)) {
            obj = pygobject_get (item);
            
            if (g_type_is_a (G_TYPE_FROM_INSTANCE (obj), gtype)) {
                ret = g_list_prepend (ret, g_object_ref (obj));
            }
        }
    }
    
    return g_list_reverse (ret);
}

static PyObject *
_wrap_gtk_source_view_show_completion (PyGObject *self, 
                                       PyObject  *args, 
                                       PyObject  *kwargs)
{
    static char *kwlist[] = { "providers", NULL };
    PyObject *providers;
    GList *items;
    
    if (!PyArg_ParseTupleAndKeywords(args,
                                         kwargs,
                                         "|O:GtkSourceView.show_completion",
                                         kwlist, &providers));

    if (providers != Py_None && !PySequence_Check(providers)) {
        PyErr_SetString(PyExc_TypeError, "providers must be a list");
        return NULL;
    }
    
    items = pylist_to_glist_gobjs (providers, GTK_TYPE_SOURCE_COMPLETION_PROVIDER);
    gtk_source_view_show_completion (GTK_SOURCE_VIEW(self->obj), items);
    
    g_list_foreach (items, (GFunc)g_object_unref, NULL);
    g_list_free (items);
        
    Py_INCREF(Py_None);
    return Py_None;
}

%%
override gtk_source_completion_show kwargs
static PyObject *
_wrap_gtk_source_completion_show(PyGObject *self,
                                  PyObject  *args,
                                  PyObject  *kwargs)
{
    static char *kwlist[] = { "providers", "criteria", "place", NULL };
    PyObject *providers;
    const char *criteria;
    GList *items;
    PyGBoxed *iter;
    
    if (!PyArg_ParseTupleAndKeywords(args,
                                         kwargs,
                                         "|OzO!:GtkSourceCompletion.show",
                                         kwlist, &providers, &criteria, &PyGtkTextIter_Type, &iter));

    if (providers != Py_None && !PySequence_Check(providers)) {
        PyErr_SetString(PyExc_TypeError, "providers must be a list");
        return NULL;
    }
    
    items = pylist_to_glist_gobjs (providers, GTK_TYPE_SOURCE_COMPLETION_PROVIDER);
    gtk_source_completion_show (GTK_SOURCE_COMPLETION(self), items, criteria, pyg_boxed_get (iter, GtkTextIter));
    
    g_list_foreach (items, (GFunc)g_object_unref, NULL);
    g_list_free (items);
    
    Py_INCREF(Py_None);
    return Py_None;
}

%%
override GtkSourceCompletionProvider__do_get_proposals kwargs
static PyObject *
_wrap_GtkSourceCompletionProvider__do_get_proposals(PyObject *cls,
                                                    PyObject *args,
                                                    PyObject *kwargs)
{
    GtkSourceCompletionProviderIface *iface;
    static char *kwlist[] = { "self", "iter", NULL };
    PyGObject *self;
    PyGBoxed *iter;
    GList *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!:GtkSourceCompletionProvider.get_proposals", kwlist, &PyGtkSourceCompletionProvider_Type, &self, &PyGtkTextIter_Type, &iter))
        return NULL;
    iface = g_type_interface_peek(g_type_class_peek(pyg_type_from_object(cls)), GTK_TYPE_SOURCE_COMPLETION_PROVIDER);
    if (iface->get_proposals)
        ret = iface->get_proposals(GTK_SOURCE_COMPLETION_PROVIDER(self->obj), pyg_boxed_get(iter, GtkTextIter));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "interface method GtkSourceCompletionProvider.get_proposals not implemented");
        return NULL;
    }
    
    return glist_to_pylist_objs (ret);
}

%%
override gtk_source_completion_provider_get_proposals kwargs
static PyObject *
_wrap_gtk_source_completion_provider_get_proposals(PyGObject *self,
                                                   PyObject  *args,
                                                   PyObject  *kwargs)
{
	GList *proposals;
	static char *kwlist[] = { "iter", NULL };
	PyGBoxed *iter;
	
	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!:GtkSourceCompletionProvider.get_proposals", kwlist,  &PyGtkTextIter_Type, &iter))
        return NULL;
	
	proposals = gtk_source_completion_provider_get_proposals (GTK_SOURCE_COMPLETION_PROVIDER (self),
	                                                          pyg_boxed_get(iter, GtkTextIter));
	
	return glist_to_pylist_objs (proposals);
}
%%
override GtkSourceCompletionProvider__proxy_do_get_proposals
static GList *
_wrap_GtkSourceCompletionProvider__proxy_do_get_proposals(GtkSourceCompletionProvider *self, GtkTextIter *iter)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    GList *retval;
    PyObject *py_retval;
    PyObject *py_method;
    PyObject *py_iter;
    PyObject *py_args;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_get_proposals");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    py_iter = pyg_boxed_new (GTK_TYPE_TEXT_ITER, iter, FALSE, FALSE);
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_iter);
    
    py_retval = PyObject_CallObject(py_method, py_args);
    Py_XDECREF(py_args);

    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    
    if (py_retval != Py_None && !PySequence_Check (py_retval)) {
        PyErr_SetString(PyExc_TypeError, "proposals must be a list");
        PyErr_Print();
        retval = NULL;
    } else {
        retval = pylist_to_glist_gobjs (py_retval, GTK_TYPE_SOURCE_COMPLETION_PROPOSAL);
    }
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}

%%
override GtkSourceCompletionProvider__proxy_do_get_info_widget

static GtkWidget*
_wrap_GtkSourceCompletionProvider__proxy_do_get_info_widget(GtkSourceCompletionProvider *self, GtkSourceCompletionProposal*proposal)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_proposal = NULL;
    GtkWidget* retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    if (proposal)
        py_proposal = pygobject_new((GObject *) proposal);
    else {
        Py_INCREF(Py_None);
        py_proposal = Py_None;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_proposal);
    
    py_method = PyObject_GetAttrString(py_self, "do_get_info_widget");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    if (!PyObject_TypeCheck(py_retval, &PyGObject_Type)) {
        PyErr_SetString(PyExc_TypeError, "retval should be a GObject");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    retval = (GtkWidget*) pygobject_get(py_retval);    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
