/* -*- C -*- */
%%
headers
#define NO_IMPORT_PYGOBJECT
#include "pygobject.h"

#include <gtksourceview/gtksourceview.h>
#include <gtksourceview/gtksourceview-typebuiltins.h>
#include <gtksourceview/gtksourcelanguagemanager.h>
#include <gtksourceview/gtksourcestyleschememanager.h>
#include <gtksourceview/gtksourcestyle.h>
#include <gtksourceview/gtksourcestylescheme.h>
#include <gtksourceview/gtksourcelanguage.h>
#include <gtksourceview/gtksourceiter.h>
#include <gtksourceview/gtksourcebuffer.h>
#include <gtksourceview/gtksourceprintcompositor.h>

static PyObject *
gslist_to_pylist_objs (const GSList *source)
{
    const GSList *iter;
    PyObject *dest = PyList_New (0);
    for (iter = source; iter != NULL; iter = iter->next)
    {
        PyObject *item = pygobject_new ((GObject *)iter->data);
        PyList_Append (dest, item);
        Py_DECREF (item);
    }
    return dest;
}

static PyObject *
strv_to_pylist (char **strv)
{
    gsize len, i;
    PyObject *list;

    len = strv ? g_strv_length (strv) : 0;
    list = PyList_New (len);

    for (i = 0; i < len; i++)
        PyList_SetItem (list, i, PyString_FromString (strv[i]));

    return list;
}

static gboolean
pylist_to_strv (PyObject *list,
                char   ***strvp)
{
    int i, len;
    char **ret;

    *strvp = NULL;

    if (list == Py_None)
        return TRUE;

    if (!PySequence_Check (list))
    {
        PyErr_Format (PyExc_TypeError, "argument must be a list or tuple of strings");
        return FALSE;
    }

    if ((len = PySequence_Size (list)) < 0)
        return FALSE;

    ret = g_new (char*, len + 1);
    for (i = 0; i <= len; ++i)
        ret[i] = NULL;

    for (i = 0; i < len; ++i)
    {
        PyObject *item = PySequence_GetItem (list, i);

        if (!item)
        {
            g_strfreev (ret);
            return FALSE;
        }

        if (!PyString_Check (item))
        {
            Py_DECREF (item);
            g_strfreev (ret);
            PyErr_Format (PyExc_TypeError, "argument must be a list of strings");
            return FALSE;
        }

        ret[i] = g_strdup (PyString_AsString (item));
        Py_DECREF (item);
    }

    *strvp = ret;
    return TRUE;
}

%%
modulename gtksourceview2

%%
import gobject.GObject as PyGObject_Type
import gtk.gdk.Pixbuf as PyGdkPixbuf_Type
import gtk.TextTagTable as PyGtkTextTagTable_Type
import gtk.TextView as PyGtkTextView_Type
import gtk.TextBuffer as PyGtkTextBuffer_Type
import gtk.TextMark as PyGtkTextMark_Type
import gtk.PrintContext as PyGtkPrintContext_Type

%%
ignore-glob
*_get_type
%%
override gtk_source_language_get_globs noargs
static PyObject *
_wrap_gtk_source_language_get_globs(PyGObject *self)
{
    gchar **globs;
    PyObject *ret;

    globs = gtk_source_language_get_globs (GTK_SOURCE_LANGUAGE (self->obj));
    ret = strv_to_pylist (globs);
    g_strfreev (globs);

    return ret;
}

%%
override gtk_source_language_get_mime_types noargs
static PyObject *
_wrap_gtk_source_language_get_mime_types(PyGObject *self)
{
    gchar **mime_types;
    PyObject *ret;

    mime_types = gtk_source_language_get_mime_types (GTK_SOURCE_LANGUAGE (self->obj));
    ret = strv_to_pylist (mime_types);
    g_strfreev (mime_types);

    return ret;
}

%%
override gtk_source_language_manager_get_language_ids noargs
static PyObject *
_wrap_gtk_source_language_manager_get_language_ids (PyGObject *self)
{
    PyObject *py_ret;
    const char * const *ret;

    ret = gtk_source_language_manager_get_language_ids (GTK_SOURCE_LANGUAGE_MANAGER (self->obj));
    py_ret = strv_to_pylist ((char**) ret);

    return py_ret;
}

%%
override gtk_source_language_manager_get_search_path noargs
static PyObject *
_wrap_gtk_source_language_manager_get_search_path(PyGObject *self)
{
    const char * const *ret;
    PyObject  *py_ret;

    ret = gtk_source_language_manager_get_search_path (GTK_SOURCE_LANGUAGE_MANAGER(self->obj));
    py_ret = strv_to_pylist ((char**) ret);

    return py_ret;
}

%%
override gtk_source_language_manager_set_search_path kwargs
static PyObject *
_wrap_gtk_source_language_manager_set_search_path (PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "dirs", NULL };
    PyObject *py_dirs;
    char **dirs;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:GtkSourceLanguageManager.set_search_path", kwlist, &py_dirs))
        return NULL;

    if (!pylist_to_strv (py_dirs, &dirs))
        return NULL;

    gtk_source_language_manager_set_search_path (GTK_SOURCE_LANGUAGE_MANAGER (self->obj), dirs);
    g_strfreev (dirs);

    Py_INCREF(Py_None);
    return Py_None;
}

%%
override gtk_source_style_scheme_manager_get_search_path noargs
static PyObject *
_wrap_gtk_source_style_scheme_manager_get_search_path(PyGObject *self)
{
    const char * const *ret;
    PyObject *py_ret;

    ret = gtk_source_style_scheme_manager_get_search_path (GTK_SOURCE_STYLE_SCHEME_MANAGER (self->obj));
    py_ret = strv_to_pylist ((char**) ret);

    return py_ret;
}

%%
override gtk_source_style_scheme_manager_set_search_path kwargs
static PyObject *
_wrap_gtk_source_style_scheme_manager_set_search_path(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "dirs", NULL };
    PyObject *py_dirs;
    char **dirs;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:GtkSourceStyleSchemeManager.set_search_path", kwlist, &py_dirs))
        return NULL;

    if (!pylist_to_strv (py_dirs, &dirs))
        return NULL;

    gtk_source_style_scheme_manager_set_search_path (GTK_SOURCE_STYLE_SCHEME_MANAGER (self->obj), dirs);
    g_strfreev (dirs);

    Py_INCREF(Py_None);
    return Py_None;
}

%%
override gtk_source_style_scheme_manager_get_scheme_ids noargs
static PyObject *
_wrap_gtk_source_style_scheme_manager_get_scheme_ids (PyGObject *self)
{
    PyObject *py_ret;
    const char * const *ret;

    ret = gtk_source_style_scheme_manager_get_scheme_ids (GTK_SOURCE_STYLE_SCHEME_MANAGER (self->obj));
    py_ret = strv_to_pylist ((char**) ret);

    return py_ret;
}

%%
override gtk_source_style_scheme_get_authors noargs
static PyObject *
_wrap_gtk_source_style_scheme_get_authors (PyGObject *self)
{
    PyObject *py_ret;
    const char * const *ret;

    ret = gtk_source_style_scheme_get_authors (GTK_SOURCE_STYLE_SCHEME (self->obj));
    py_ret = strv_to_pylist ((char**) ret);

    return py_ret;
}

%%
override-slot GtkSourceLanguage.tp_new
static PyObject *
_wrap_gtk_source_language_tp_new(PyTypeObject *type)
{
    PyErr_SetString(PyExc_TypeError,
		    "cannot create instance of type `GtkSourceLanguage'");
    return NULL;
}

%%
override-slot GtkSourceStyleScheme.tp_new
static PyObject *
_wrap_gtk_source_style_scheme_tp_new(PyTypeObject *type)
{
    PyErr_SetString(PyExc_TypeError,
		    "cannot create instance of type `GtkSourceStyleScheme'");
    return NULL;
}

%%
override gtk_source_language_get_style_ids noargs
static PyObject *
_wrap_gtk_source_language_get_style_ids(PyGObject *self)
{
    gchar       **ret;
    PyObject    *py_ret;

    ret = gtk_source_language_get_style_ids(GTK_SOURCE_LANGUAGE(self->obj));
    py_ret = strv_to_pylist ((char**) ret);

    return py_ret;
}

%%
override gtk_source_buffer_get_marks_at_iter kwargs 	 
static PyObject * 	 
_wrap_gtk_source_buffer_get_marks_at_iter(PyGObject *self, 	 
                                          PyObject *args, 	 
                                          PyObject *kwargs) 	 
{ 	 
    static char *kwlist[] = { "iter", "category", NULL }; 	 
    PyObject    *py_iter, *py_ret;
    gchar       *category;
    GtkTextIter *iter = NULL;
    GSList      *ret; 	 

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, 	 
                                     "Os:GtkSourceBuffer.get_marks_at_iter", 	 
                                     kwlist, &py_iter, &category)) 	 
        return NULL; 	 

    if (pyg_boxed_check(py_iter, GTK_TYPE_TEXT_ITER)) 	 
        iter = pyg_boxed_get(py_iter, GtkTextIter); 	 
    else { 	 
        PyErr_SetString(PyExc_TypeError, "iter should be a GtkTextIter"); 	 
        return NULL; 	 
    }	 

    ret = gtk_source_buffer_get_marks_at_iter(GTK_SOURCE_BUFFER(self->obj), 	 
                                              iter, category); 	 

    py_ret = gslist_to_pylist_objs (ret); 	 

    return py_ret; 	 
} 	 

%%
override gtk_source_buffer_get_marks_at_line kwargs 	 
static PyObject * 	 
_wrap_gtk_source_buffer_get_marks_at_line(PyGObject *self, 	 
                                          PyObject *args, 	 
                                          PyObject *kwargs) 	 
{ 	 
    static char *kwlist[] = { "line", "category", NULL }; 	 
    PyObject    *py_ret;
    gint        line;
    gchar       *category;
    GSList      *ret; 	 

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, 	 
                                     "is:GtkSourceBuffer.get_marks_at_iter", 	 
                                     kwlist, &line, &category)) 	 
        return NULL;

    ret = gtk_source_buffer_get_marks_at_line(GTK_SOURCE_BUFFER(self->obj), 	 
                                              line, category); 	 

    py_ret = gslist_to_pylist_objs (ret); 	 

    return py_ret; 	 
} 	 

%%
override gtk_source_iter_backward_search kwargs
static PyObject *
_wrap_gtk_source_iter_backward_search(PyObject *self, PyObject *args,
                                      PyObject *kwargs)
{
    static char *kwlist[] = { "iter", "str", "flags", "limit", NULL };
    gchar *str;
    PyObject *py_flags, *py_iter, *py_limit = Py_None;
    GtkTextIter match_start, match_end, *iter = NULL, *limit = NULL;
    GtkSourceSearchFlags flags;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                    "OsO|O:gtksourceview2.iter_backward_search",
                                    kwlist, &py_iter, &str, &py_flags,
                                    &py_limit))
        return NULL;

    if (pyg_boxed_check(py_iter, GTK_TYPE_TEXT_ITER))
        iter = pyg_boxed_get(py_iter, GtkTextIter);

    if (pyg_boxed_check(py_limit, GTK_TYPE_TEXT_ITER))
        limit = pyg_boxed_get(py_limit, GtkTextIter);

    else if (py_limit != Py_None) {
        PyErr_SetString(PyExc_TypeError,"limit must be a GtkTextIter or None");
        return NULL;
    }

    if (pyg_flags_get_value(GTK_TYPE_TEXT_SEARCH_FLAGS, py_flags,
                            (gint *)&flags))
        return NULL;

    if (gtk_source_iter_backward_search(iter, str, flags, &match_start,
                                        &match_end, limit))
        return Py_BuildValue("(NN)",
                             pyg_boxed_new(GTK_TYPE_TEXT_ITER, &match_start,
                                           TRUE, TRUE),
                             pyg_boxed_new(GTK_TYPE_TEXT_ITER, &match_end,
                                           TRUE, TRUE));

    Py_INCREF(Py_None);
    return Py_None;
}

%%
override gtk_source_iter_forward_search kwargs
static PyObject *
_wrap_gtk_source_iter_forward_search(PyObject *self, PyObject *args,
                                      PyObject *kwargs)
{
    static char *kwlist[] = { "iter", "str", "flags", "limit", NULL };
    gchar *str;
    PyObject *py_flags, *py_iter, *py_limit = Py_None;
    GtkTextIter match_start, match_end, *iter = NULL, *limit = NULL;
    GtkSourceSearchFlags flags;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                    "OsO|O:gtksourceview2.iter_forward_search",
                                    kwlist, &py_iter, &str, &py_flags,
                                    &py_limit))
        return NULL;

    if (pyg_boxed_check(py_iter, GTK_TYPE_TEXT_ITER))
        iter = pyg_boxed_get(py_iter, GtkTextIter);

    if (pyg_boxed_check(py_limit, GTK_TYPE_TEXT_ITER))
        limit = pyg_boxed_get(py_limit, GtkTextIter);

    else if (py_limit != Py_None) {
        PyErr_SetString(PyExc_TypeError,"limit must be a GtkTextIter or None");
        return NULL;
    }

    if (pyg_flags_get_value(GTK_TYPE_TEXT_SEARCH_FLAGS, py_flags,
                            (gint *)&flags))
        return NULL;

    if (gtk_source_iter_forward_search(iter, str, flags, &match_start,
                                        &match_end, limit))
        return Py_BuildValue("(NN)",
                             pyg_boxed_new(GTK_TYPE_TEXT_ITER, &match_start,
                                           TRUE, TRUE),
                             pyg_boxed_new(GTK_TYPE_TEXT_ITER, &match_end,
                                           TRUE, TRUE));

    Py_INCREF(Py_None);
    return Py_None;
}
